code Synch

  -- OS Class: Project 2
  --
  -- <PUT YOUR NAME HERE>

-----------------------------  Semaphore  ---------------------------------

  behavior Semaphore
    -- This class provides the following methods:
    --    Up()  ...also known as "V" or "Signal"...
    --         Increment the semaphore count.  Wake up a thread if
    --         there are any waiting.  This operation always executes
    --         quickly and will not suspend the thread.
    --    Down()   ...also known as "P" or "Wait"...
    --         Decrement the semaphore count.  If the count would go
    --         negative, wait for some other thread to do an Up()
    --         first.  Conceptually, the count will never go negative.
    --    Init(initialCount)
    --         Each semaphore must be initialized.  Normally, you should
    --         invoke this method, providing an 'initialCount' of zero.
    --         If the semaphore is initialized with 0, then a Down()
    --         operation before any Up() will wait for the first
    --         Up().  If initialized with i, then it is as if i Up()
    --         operations have been performed already.
    --
    -- NOTE: The user should never look at a semaphore's count since the value
    -- retrieved may be out-of-date, due to other threads performing Up() or
    -- Down() operations since the retrieval of the count.

      ----------  Semaphore . Init  ----------

      method Init (initialCount: int)
          if initialCount < 0
            FatalError ("Semaphore created with initialCount < 0")
          endIf
          count = initialCount
          waitingThreads = new List [Thread]
        endMethod

      ----------  Semaphore . Up  ----------

      method Up ()
          var
            oldIntStat: int
            t: ptr to Thread
          oldIntStat = SetInterruptsTo (DISABLED)
          if count == 0x7fffffff
            FatalError ("Semaphore count overflowed during 'Up' operation")
          endIf
          count = count + 1
          if count <= 0
            t = waitingThreads.Remove ()
            t.status = READY
            readyList.AddToEnd (t)
          endIf
          oldIntStat = SetInterruptsTo (oldIntStat)
        endMethod

      ----------  Semaphore . Down  ----------

      method Down ()
          var
            oldIntStat: int
          oldIntStat = SetInterruptsTo (DISABLED)
          if count == 0x80000000
            FatalError ("Semaphore count underflowed during 'Down' operation")
          endIf
          count = count - 1
          if count < 0
            waitingThreads.AddToEnd (currentThread)
            currentThread.Sleep ()
          endIf
          oldIntStat = SetInterruptsTo (oldIntStat)
        endMethod

  endBehavior

-----------------------------  Mutex  ---------------------------------

  behavior Mutex
    -- This class provides the following methods:
    --    Lock()
    --         Acquire the mutex if free, otherwise wait until the mutex is
    --         free and then get it.
    --    Unlock()
    --         Release the mutex.  If other threads are waiting, then
    --         wake up the oldest one and give it the lock.
    --    Init()
    --         Each mutex must be initialized.
    --    IsHeldByCurrentThread()
    --         Return TRUE iff the current (invoking) thread holds a lock
    --         on the mutex.

      ----------  Mutex . Init  ----------

      method Init ()
          if waitCount < 0
            FatalError ("Mutex created with waitCount < 0")
          endIf

          -- set up our variables:
          -- heldBy: the Thread that is holding the lock
          heldBy = null
          -- state: the lock itself
          state = UNLOCKED
          -- waitingThreads: FIFO queue of threads that are asleep, waiting for lock
          waitingThreads = new List [Thread]
          -- waitCount: the number of items on the list/queue.
          waitCount = 0
        endMethod

      ----------  Mutex . Lock  ----------

      method Lock ()
          var oldIntStat: int

          -- critical section, disable interrupts.
          oldIntStat = SetInterruptsTo (DISABLED)

          while state == LOCKED
            -- print (" sleeping on lock, we don't have it (")
            -- print (currentThread.name)
            -- print (").\n")
            waitingThreads.AddToEnd (currentThread)
            waitCount = waitCount + 1
            currentThread.Sleep ()
          endWhile

          -- We are guaranteed to have state=UNLOCKED at this point.
          -- mutex is free, so we'll acquire it.
          -- print (" getting the lock for ")
          -- print (currentThread.name)
          -- print ("\n")

          -- sanity-check/assert that we aren't locking an already-held lock
          if heldBy != null
            -- print ("holding a held lock. state: ")
            -- if (state == LOCKED)
            --   print ("locked")
            -- endIf
            -- print ("\n")
            FatalError ("about to hold a held lock, eep!")
          endIf

          state = LOCKED
          heldBy = currentThread
          oldIntStat = SetInterruptsTo (oldIntStat)
        endMethod

      ----------  Mutex . Unlock  ----------

      method Unlock ()
          var 
              oldIntStat: int
              nextThread: ptr to Thread

          oldIntStat = SetInterruptsTo (DISABLED)

          if state == UNLOCKED
            FatalError ("asked for lock to be released, but nothing was locked!")
          endIf

          -- Make sure we are releasing a lock that we hold, not someone else.
          if heldBy != currentThread
            -- print ("heldby: ")
            -- print (heldBy.name)
            -- print (" .. currentThread: ")
            -- print (currentThread.name)
            -- print ("\n")
            FatalError ("thread was not locked by currentThread.")
          endIf

          -- print (" unlocking for ")
          -- print (currentThread.name)
          -- print ("\n")
          -- Actually release the lock, now that we've verified everything.
          state = UNLOCKED
          heldBy = null

          -- pull our next thread from the (lock) waiting list.
          -- Don't start it, but mark it ready.
          if waitCount > 0
            waitCount = waitCount - 1
            nextThread = waitingThreads.Remove()
            nextThread.status = READY
            readyList.AddToEnd (nextThread)
          endIf

          oldIntStat = SetInterruptsTo (oldIntStat)
        endMethod

      ----------  Mutex . IsHeldByCurrentThread  ----------

      method IsHeldByCurrentThread () returns bool
          if (state == LOCKED && heldBy == currentThread)
            return true
          endIf

          return false
        endMethod

  endBehavior

-----------------------------  Condition  ---------------------------------

  behavior Condition
    -- This class is used to implement monitors.  Each monitor will have a
    -- mutex lock and one or more condition variables.  The lock ensures that
    -- only one process at a time may execute code in the monitor.  Within the
    -- monitor code, a thread can execute Wait() and Signal() operations
    -- on the condition variables to make sure certain condions are met.
    --
    -- The condition variables here implement "Mesa-style" semantics, which
    -- means that in the time between a Signal() operation and the awakening
    -- and execution of the corrsponding waiting thread, other threads may
    -- have snuck in and run.  The waiting thread should always re-check the
    -- data to ensure that the condition which was signalled is still true.
    --
    -- This class provides the following methods:
    --    Wait(mutex)
    --         This method assumes the mutex has alreasy been locked.
    --         It unlocks it, and goes to sleep waiting for a signal on
    --         this condition.  When the signal is received, this method
    --         re-awakens, re-locks the mutex, and returns.
    --    Signal(mutex)
    --         If there are any threads waiting on this condition, this
    --         method will wake up the oldest and schedule it to run.
    --         However, since this thread holds the mutex and never unlocks
    --         it, the newly awakened thread will be forced to wait before
    --         it can re-acquire the mutex and resume execution.
    --    Broadcast(mutex)
    --         This method is like Signal() except that it wakes up all
    --         threads waiting on this condition, not just the next one.
    --    Init()
    --         Each condition must be initialized.

      ----------  Condition . Init  ----------

      method Init ()
          waitingThreads = new List [Thread]
        endMethod

      ----------  Condition . Wait  ----------

      method Wait (mutex: ptr to Mutex)
          var
            oldIntStat: int
          if ! mutex.IsHeldByCurrentThread ()
            FatalError ("Attempt to wait on condition when mutex is not held")
          endIf
          oldIntStat = SetInterruptsTo (DISABLED)
          mutex.Unlock ()
          waitingThreads.AddToEnd (currentThread)
          currentThread.Sleep ()
          mutex.Lock ()
          oldIntStat = SetInterruptsTo (oldIntStat)
        endMethod

      ----------  Condition . Signal  ----------

      method Signal (mutex: ptr to Mutex)
          var
            oldIntStat: int
            t: ptr to Thread
          if ! mutex.IsHeldByCurrentThread ()
            FatalError ("Attempt to signal a condition when mutex is not held")
          endIf
          oldIntStat = SetInterruptsTo (DISABLED)
          t = waitingThreads.Remove ()
          if t
            t.status = READY
            readyList.AddToEnd (t)
          endIf
          oldIntStat = SetInterruptsTo (oldIntStat)
        endMethod

      ----------  Condition . Broadcast  ----------

      method Broadcast (mutex: ptr to Mutex)
          var
            oldIntStat: int
            t: ptr to Thread
          if ! mutex.IsHeldByCurrentThread ()
            FatalError ("Attempt to broadcast a condition when lock is not held")
          endIf
          oldIntStat = SetInterruptsTo (DISABLED)
          while true
            t = waitingThreads.Remove ()
            if t == null
              break
            endIf
            t.status = READY
            readyList.AddToEnd (t)
          endWhile
          oldIntStat = SetInterruptsTo (oldIntStat)
        endMethod

  endBehavior

endCode
